JS code is non-blocking
So callbacks and events are used to change the order
of code execution

Event loop starts automatically.

The callback functions does not stop
later parts of the code. They does work
side by side.

There is default separation method to separate
different requests.

writeFileSync() sends response before executing itself
writeFile execute first and blocks rest of the code

npm init
nmp install nodemon
sudo npm install nodemon -g
npm install --save express
npm install --save body-parser
npm install --save ejs pug express-handlebars
npm install --save mysql2
npm install sequelize
npm install --save mongodb
npm install --save mongoose
npm install --save express-session
npm install --save connect-mongodb-session
npm install --save bcryptjs
npm install --save csurf
npm install --save connect-flash
npm install --save express-validator

The good thing about local dependencies is that you can share 
projects without the node_modules folder (where they are stored) 
and you can run npm install in a project to then re-create that 
node_modules folder. This allows you to share only your source code, 
hence reducing the size of the shared project vastly.

You could install nodemon globally if you wanted (this is NOT required 
though - because we can just run it locally): npm install -g nodemon 
would do the trick. Specifically the -g flag ensures that the package 
gets added as a global package which you now can use anywhere on your 
machine, directly from inside the terminal or command prompt.

next() helps to go the next middleware

app.use(bodyParser.urlencoded({extended:false}));
{extended:false} for non-default features

'get', 'post' or others look for exact match
while 'use' only looks for the minimum match

Dynamic Routes
router.get("/products/delete", shopController.getProducts);
router.get("/products/:productId", shopController.getProducts);

if delete route was in 2nd, it will never be fired

Json file cant be empty

MySql community and MySql workBench downloads
sudo mysql -u root -p
Addy@789**$

sequelize.sync() automatic creates table if not exists

Product.findAll({ where: { id: prodId } })
Product.findByPk(prodId)
Product.findAll()

Product.findByPk(prodId)
    .then((product) =>             [Promise 1]
      {return product.save()})     [Promise 2]
    .then(() => {
      console.log("Done!");        {prints both promise}
    })
    .catch();

req.user.getProducts()
req.user.getProducts({where:{id:prodId}})

In Middleware res.redirect() is must for POST request

'getX' is not for templates and returns object
It is for further work returns array

mongodb
db = getDb()
db.collection('a').collection('a').insertOne(this).then().catch()

db.collection('a').collection('a').updateOne({_id:new mongodb.ObjectId(id)}, {$set:this }).then().catch()

return db.collection('a').find().toArray().then().catch()
or
return db.collection('a').find().next().then().catch()

const mongodb = require('mongodb')
db.collection('a').find({_id:new mongodb.ObjectId(id)})

db.collection('a').deleteOne({_id:new mongodb.ObjectId(id)}).then().catch()

app.use((req, res, next) => {
  User.findByPk(1)
    .then((user) => {
      req.user = user;
      next();
    })
    .catch();
});

Every request assign this req.user
If we set an header then only for that link
this req.user will be assigned

custom throw an error or promise